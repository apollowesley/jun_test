Servlet3.0中Servlet的使用
目录
1.注解配置
2.异步调用

       相对于之前的版本，Servlet3.0中的Servlet有以下改进：
l  支持注解配置。
l  支持异步调用。
l  直接有对文件上传的支持。
 
       在这篇文章中我将主要讲这三方面的应用示例。
 
1.注解配置

       在以往我们的Servlet都需要在web.xml文件中进行配置（Servlet3.0同样支持），但是在Servlet3.0中引入了注解，
我们只需要在对应的Servlet类上使用@WebServlet注解进行标记，我们的应用启动之后就可以访问到该Servlet。
对于一个@WebServlet而言，有一个属性是必须要的，那就是它的访问路径。@WebServlet中有两个属性可以用来表示Servlet的访问路径，分别是value和urlPatterns。
value和urlPatterns都是数组形式，表示我们可以把一个Servlet映射到多个访问路径，但是value和urlPatterns不能同时使用。
如果同时使用了value和urlPatterns，我们的Servlet是无法访问到的。下面是一个使用@WebServlet的简单Servlet示例。

/**
 * Servlet3.0支持使用注解配置Servlet。我们只需在Servlet对应的类上使用@WebServlet进行标注， 
 * 我们就可以访问到该Servlet了，而不需要再在web.xml文件中进行配置。@WebServlet的urlPatterns 
 * 和value属性都可以用来表示Servlet的部署路径，它们都是对应的一个数组。 
 */
@WebServlet(name="exampleServlet", urlPatterns="/servlet/example")
public class ExampleServlet extends HttpServlet {

   private static final long serialVersionUID = 1L;

   @Override
   protected void doGet(HttpServletRequest request,
         HttpServletResponse response) throws ServletException, IOException {
      this.doPost(request, response);
   }

   @Override
   protected void doPost(HttpServletRequest request,
         HttpServletResponse response) throws ServletException, IOException {
      response.getWriter().write("Hello User.");
   }
}

2.异步调用

       在Servlet3.0中，在Servlet内部支持异步处理。它的逻辑是当我们请求一个Servlet时，我们的Servlet可以先返回一部分内容给客户端。
然后在Servlet内部异步处理另外一段逻辑，等到异步处理完成之后，再把异步处理的结果返回给客户端。
这意味着当我们的Servlet在处理一段比较费时的业务逻辑时，我们可以先返回一部分信息给客户端，然后异步处理费时的业务，而不必让客户端一直等待所有的业务逻辑处理完。
等到异步处理完之后，再把对应的处理结果返回给客户端。
       异步调用是通过当前HttpServletRequest的startAsync()方法开始的，它返回一个AsyncContext。
之后我们可以调用AsyncContext的start()方法来新起一个线程进行异步调用。
在新线程内部程序的最后我们最好是调用一下当前AsyncContext的complete()方法，否则异步调用的结果需要等到设置的超时时间过后才会返回到客户端。
另外当异步调用超时以后会接着调用异步任务，即新起的线程。
Java代码

import java.io.IOException;  
import java.io.PrintWriter;  
   
import javax.servlet.AsyncContext;  
import javax.servlet.ServletException;  
import javax.servlet.annotation.WebServlet;  
import javax.servlet.http.HttpServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
   
/** 
 * 支持异步返回的Servlet 
 * 对于Servlet的异步返回，首先我们必须指定@WebServlet的asyncSupported属性为true（默认是false），同时在它之前的Filter 
 * 的asyncSupported属性也必须是true，否则传递过来的request就是不支持异步调用的。 
 */  
@WebServlet(value="/servlet/async", asyncSupported=true)  
public class AsyncServlet extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @Override
   protected void doGet(HttpServletRequest req, HttpServletResponse resp)
         throws ServletException, IOException {
      this.doPost(req, resp);
   }

   @Override
   protected void doPost(HttpServletRequest req, HttpServletResponse resp)
         throws ServletException, IOException {
      resp.setContentType("text/plain;charset=UTF-8");
      final PrintWriter writer = resp.getWriter();
      writer.println("异步之前输出的内容。");
      writer.flush();
      //开始异步调用，获取对应的AsyncContext。
      final AsyncContext asyncContext = req.startAsync();
      //设置超时时间，当超时之后程序会尝试重新执行异步任务，即我们新起的线程。
      asyncContext.setTimeout(10*1000L);
      //新起线程开始异步调用，start方法不是阻塞式的，它会新起一个线程来启动Runnable接口，之后主程序会继续执行
      asyncContext.start(new Runnable() {

         @Override
         public void run() {
            try {
                Thread.sleep(5*1000L);
                writer.println("异步调用之后输出的内容。");
                writer.flush();
                //异步调用完成，如果异步调用完成后不调用complete()方法的话，异步调用的结果需要等到设置的超时
                //时间过了之后才能返回到客户端。
                asyncContext.complete();
            } catch (Exception e) {
                e.printStackTrace();
            }
         }
      });
      writer.println("可能在异步调用前输出，也可能在异步调用之后输出，因为异步调用会新起一个线程。");
      writer.flush();
   }
}
	对于一个Servlet如果要支持异步调用的话我们必须指定其asyncSupported属性为true（默认是false）。
使用@WebServlet注解标注的Servlet我们可以直接指定其asyncSupported属性的值为true，如：@WebServlet(value=”/servlet/async”, asyncSupported=true)。
而对于在web.xml文件中进行配置的Servlet来说，我们需要在配置的时候指定其asyncSupported属性为true。
Xml代码
<servlet>
   <servlet-name>xxxName</servlet-name>
   <servlet-class>xxx.class</servlet-class>
   <async-supported>true</async-supported>
</servlet>
<servlet-mapping>
   <servlet-name>xxxName</servlet-name>
   <url-pattern>xxx</url-pattern>
</servlet-mapping> 

Servlet的异步调用程序的关键是要调用当前HttpServletRequest的startAsync()方法。
至于利用返回的AsyncContext来新起一个线程进行异步处理就不是那么的必须了，因为在HttpServletRequest startAsync()之后，我们可以自己新起线程进行异步处理。
