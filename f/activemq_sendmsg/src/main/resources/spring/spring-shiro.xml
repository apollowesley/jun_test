<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd 
	                   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
	                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd
	                   http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd"
	default-lazy-init="true">


	<description>Shiro资源权限控制 配置</description>

	<aop:aspectj-autoproxy proxy-target-class="false" />
   
	<!--shiro过滤器配置，bean的id值须与web中的filter-name的值相同 -->
	<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
		<!-- shiro的核心安全接口 -->
		<property name="securityManager" ref="securityManager" />
		<!-- 要求登录时的链接 -->
		<property name="loginUrl" value="/login/toLogin" />
		<!-- 登陆成功后要跳转的连接 -->
		<property name="successUrl" value="/home" />

		<!-- 未授权时要跳转的连接 -->
		<!-- <property name="unauthorizedUrl" value="/WEB-INF/view/unauthorized.jsp"/> -->
    

		<!-- shiro连接约束配置: anon： 不需要任何权限即可访问 authc：表示访问该地址用户必须身份验证通过（Subject. isAuthenticated()==true） 
			user：表示访问该地址的用户是身份验证通过或RememberMe登录的都可以 -->
		<!-- 使用自定义过滤器的时候，配置方式比如：/index.jsp = role[user] 即：访问/index.jsp资源，需要有user角色才可访问. -->
		<property name="filterChainDefinitions">
			<value>
				/resources/** = anon
				/index.jsp = anon
				/login/** = anon
				/verifyCode = anon
				/index/page = anon
				/** = authc
			</value>
		</property>
	</bean>
    
	<!-- 后置处理程序自动调用init()和destroy()方法 -->
	<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />

	<!-- Shiro支持对方法级别的权限控制 -->
	<bean
		class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator">
		<property name="proxyTargetClass" value="true" />
	</bean>

	<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
		<property name="securityManager" ref="securityManager" />
	</bean>

	<!--securityManager是shiro的核心，初始化时协调各个模块运行 -->
	<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
		<!--单个realm使用realm,如果有多个realm，使用realms属性代替 -->
		<property name="realm" ref="globalAuthorizingRealm" />


		<!-- ===========================================对于缓存这块的性能描述============================================================== -->
		
		<!-- 
			经过实际项目的运行测试，发现这部分缓存配置的重要性。
			1、【未配置cacheManager】 ： 如果没有配置 cacheManager属性，则shiro本身会检测是否配置了缓存机制(cacheManager)，如果没有，则会连续请求5次(可以理解为心跳机制，5次之后就不会继续重复请求了)，导致项目页面响应时间长。
			2、【配置了cacheManager】 ： 如果配置了 cacheManager属性，则只会请求1次，大大节省项目页面响应速度。
		-->
		
		<!-- 内存机制记录登录用户信息 -->
		<!-- <property name="cacheManager" ref="shiroMemoryCacheManager" /> -->
		<!-- 缓存机制记录登录用户信息，使用EhCache缓存 -->
		<!-- <property name="cacheManager" ref="shiroCacheManager" /> -->
		<!-- =============================================================================================================================== -->

        <!-- sessionManager -->
	    <property name="sessionManager" ref="sessionManager" />
	 
	    <!-- 使用redis缓存 -->
	    <property name="cacheManager" ref="cacheManager" />

		<!-- Cookie机制实现:记住我 -->
		<property name="rememberMeManager" ref="rememberMeManager" />
	</bean>
    
    <!-- shiro redisManager 服务配置-->
	<bean id="redisManager" class="org.crazycake.shiro.RedisManager">
	    <property name="host" value="123.57.162.75"/>
	    <property name="port" value="6379"/>
	    <property name="expire" value="1800"/>
	    
	    <!-- 选填属性:-->
	    <!-- 
	    <property name="timeout" value="10000"/>
	    <property name="password" value="123456"/>
	     -->
	</bean>
    <!-- 这个对象主要作用是：之前是shiro来管理session的，现在需要将session存入redis中，目的是为了实现负载均衡控制。实现主从服务器中，若一个服务器挂了，则不会影响用户的系统继续使用操作。 -->
	<bean id="redisSessionDAO" class="org.crazycake.shiro.RedisSessionDAO">
	    <property name="redisManager" ref="redisManager" />
	</bean>
	 
	<!-- session管理器，注入redis的session管理器 -->
	<bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
	    <property name="sessionDAO" ref="redisSessionDAO" />
	</bean>
    
    <!-- 缓存管理，注入redis缓存管理器 -->
	<bean id="cacheManager" class="org.crazycake.shiro.RedisCacheManager">
	    <property name="redisManager" ref="redisManager" />
	</bean>
	

	<!-- rememberMe管理器 -->
	<bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
		<property name="cipherKey"
			value="#{T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')}" />

		<!-- Shiro自身提供Cookie的实现有以下2种.任选其一. 大多数采用rememberMeCookie的实现。 -->
		<property name="cookie" ref="rememberMeCookie" />
		<!-- <property name="cookie" ref="sessionIdCookie"/> -->
	</bean>

	<!-- 会话Cookie模板。maxAge=-1表示浏览器关闭时失效此Cookie -->
	<bean id="sessionIdCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
		<constructor-arg value="sid" />
		<property name="httpOnly" value="true" />
		<property name="maxAge" value="-1" />
	</bean>
	<!-- 即记住我的Cookie，保存时长1小时 -->
	<bean id="rememberMeCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
		<constructor-arg value="rememberMe" />
		<property name="httpOnly" value="true" />
		<property name="maxAge" value="3600" /><!-- 1小时，秒为单位 -->
	</bean>



    <!-- 用户授权/认证信息Cache -->
    <!-- 基于内存机制记录当前登录用户信息 -->
    <!-- <bean id="shiroMemoryCacheManager" class="org.apache.shiro.cache.MemoryConstrainedCacheManager"/> -->
    <!-- 使用缓存记录当前登录用户信息（目前项目集成了redis，则该ehcache暂时不去使用它） -->
    <!-- 
    <bean id="shiroCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManager" ref="ehCacheManager" />
    </bean>
    -->
 
	<!-- shiro权限全局异常 -->
	<bean class="com.zb.shiro.OperatorExceptionResolver" />
	
	
	<bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
        <property name="staticMethod" value="org.apache.shiro.SecurityUtils.setSecurityManager" />
        <property name="arguments" ref="securityManager" />
    </bean>
</beans>