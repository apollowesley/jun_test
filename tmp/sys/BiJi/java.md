### 简述java垃圾回收机制?
在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
### JVM内存模型
![输入图片说明](https://gitee.com/uploads/images/2018/0115/165627_bd065fe7_1478371.png "屏幕截图.png")
![输入图片说明](https://gitee.com/uploads/images/2018/0115/165643_1485178e_1478371.png "屏幕截图.png")
### 运行时数据区存储了哪些数据？
1.程序计数器(PC寄存器)
  - 　由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，
 - 　　因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，
 - 　　否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，
 - 　　因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。


2. java栈
  - Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、
3. 堆
  - Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。
4. 方法区
 - 与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变
 量、常量以及编译器编译后的代码等。
 - 在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号
 引用。
 - 在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加
 载到JVM后，
 - 对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常
 量放入运行时常量池中，比如String的intern方法。

### Java虚拟机类加载机制
 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解
析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示。 


![输入图片说明](https://gitee.com/uploads/images/2018/0115/170518_0323b917_1478371.png "屏幕截图.png")


 **加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。** 


- 类的生命周期是：加载->验证->准备->解析->初始化->使用->卸载，只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值

### Java中赋值顺序


1. 父类的静态变量赋值 
1. 自身的静态变量赋值 
1. 父类成员变量赋值 
1. 父类块赋值 
1. 父类构造函数赋值 
1. 自身成员变量赋值 
1. 自身块赋值 
1. 自身构造函数赋值

### 索引类型



1. 唯一索引：唯一索引不允许两行具有相同的索引值
1. 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
1. 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个
1. 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个
### 优点


- 加快访问速度，加强行的唯一性
### 缺点

- 带索引的表在数据库中需要更多的存储空间
- 操纵数据的命令需要更长的处理时间，因为它们需要对索引进行更新

### 数据库事务并发会引起那些常见问题以及对应的解决方法？
1. 丢失更新：撤消一个事务时，把其它事务已提交的更新的数据覆盖了。
1. 脏读：一个事务读到另一个事务未提交的更新数据。
1. 幻读：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。
1. 不可重复读：一个事务两次读同一行数据，可是这两次读到的数据不一样。

### 为了解决多个事务并发会引发的问题。数据库系统提供了四种事务隔离级别供用户选择   
1. Serializable：串行化。隔离级别最高。   
1. Repeatable Read：可重复读。  
1. Read Committed：读已提交数据。 
1. Read Uncommitted：读未提交数据。隔离级别最差。

### java集合框架解析

![输入图片说明](https://gitee.com/uploads/images/2018/0115/172442_348de601_1478371.png "屏幕截图.png")


- Map系：HashMap, LinkedHashMap, TreeMap, WeakHashMap, EnumMap;
- List系：ArrayList, LinkedList, Vector, Stack;
- Set系：HashSet, LinkedHashSet, TreeSet;
-  **如图** 
![输入图片说明](https://gitee.com/uploads/images/2018/0115/172942_7a81eea8_1478371.png "屏幕截图.png")

### set接口的3种实现：


1. HashSet的对象必须实现hashCode方法，javaAPI大多数类实现了hashCode方法。
1. LinkedHashSet实现了对HashSet的扩展，支持规则集内元素的排序，在HashSet中元素是没有顺序的，而在LinkedHashSet中，可以按元素插入集合的顺序进行提取
1. TreeSet保证集中的元素是有序的，有2种方法可以实现对象之间的可比较性：
1，添加到TreeSet的对象实现了Comparable接口；
2，给规则集的元素指定一个比较器（Comparator）

### List的几种实现


1. 最重要的的当然是ArrayList（不同步）和LinkedList，一个使用数组实现的动态扩展容量的list，一个是链式实现的list。
1. 还有就是Vector（同步）类，它除了包含访问和修改向量的同步方法之外，跟ArrayList一样。
1. 最后就是Stack类，它继承自Vector类，，但一般只作为栈的功能来使用，不要去使用Vector里面的功能

### HashMap的工作原理:


- 在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)。 
- Capacity的默认值为16： 
- static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
- 负载因子的默认值为0.75： 
- static final float DEFAULT_LOAD_FACTOR = 0.75f; 

### 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？
如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。
简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例

### 你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？ 

- HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。

- 当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。

### ArrayList定义  
- 构造ArrayList的时候，默认初始化容量为10  扩容长度是旧长度的1.5倍+1（因为0的1.5还是0。确切的来说应该是：+1的1.5倍。）每一次的扩容代表着创建新数组对象，复制原有数据。
- ArrayList以数组实现，允许重复。超出限制时会增加50%的容量
每次扩容都底层采用System.arrayCopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建数组的大小为10 ,按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。
- 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。
- ArrayList中有一个方法trimToSize()用来缩小elementData数组的大小，这样可以节约内存：

### ArrayList和LinkedList的区别

ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。

### ArrayList和Vector的区别


- 1 Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。
- 2 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 
- 3 Vector还有一个子类Stack.

### Set几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object。Set的特征也继承了那些内部Map实现的特征。

### volatile关键字的理解 具有了以下两点特性：
- 1 . 保证了不同线程对该变量操作的内存可见性;
- 2 . 禁止指令重排序
### 什么是内存可见性，什么又是重排序呢？
- java内存模型（JMM）
- Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。
- 简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。
- 在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。
![输入图片说明](https://gitee.com/uploads/images/2018/0115/174810_c2cf9b5b_1478371.png "屏幕截图.png")
-  在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内 **存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。
- 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：
```
i = i + 1;
```
假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：
![输入图片说明](https://gitee.com/uploads/images/2018/0115/175103_10f77689_1478371.png "屏幕截图.png")
- 如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。下面就要提到你刚才问到的问题了
[JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。
](http://note.youdao.com/noteshare?id=5707bad942370622d8da28965f885131&sub=6185E0C78A2C42B7B517472F8ADE6674)